<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PVME Tilemap</title>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <link href="./assets/index.css" rel="stylesheet" />
  </head>

  <body
    style="
      margin: 0;
      font-family: ui-sans-serif, system-ui;
      background: #0f172a;
      color: #e2e8f0;
      display: flex;
      height: 100vh;
      overflow: hidden;
    "
  >
    <!-- Sidebar -->
    <div
      style="
        width: 300px;
        background: #111827;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        box-shadow: inset -1px 0 0 rgba(255, 255, 255, 0.05);
        flex-shrink: 0;
      "
    >
      <!-- Header -->
      <div
        style="
          display: flex;
          flex-direction: column;
          gap: 12px;
          margin-bottom: 10px;
        "
      >
        <!-- Logo -->
        <div style="display: flex; align-items: center; gap: 10px">
          <img
            src="https://img.pvme.io/images/EPzzJe2xy6.gif"
            alt="PVME"
            style="
              height: 36px;
              width: auto;
              pointer-events: none;
              user-select: none;
            "
          />
          <div style="font-weight: 700; font-size: 16px; letter-spacing: 0.5px">
            PvME Tilemap Maker
          </div>
        </div>

        <div style="font-size: 14px; opacity: 0.7; line-height: 1.5">
          Drag elements onto the map. Scroll to zoom. Click & drag to pan. Click
          elements to edit or resize. Press "Download PNG" to crop & export.
        </div>

        <div style="height: 1px; background: rgba(255, 255, 255, 0.06)"></div>
      </div>

      <!-- Starting Position -->
      <div
        style="
          background: #1e293b;
          padding: 16px;
          border-radius: 12px;
          display: flex;
          flex-direction: column;
          gap: 12px;
        "
      >
        <h3
          style="
            margin: 0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            opacity: 0.6;
          "
        >
          Starting Position
        </h3>

        <div style="display: flex; gap: 8px">
          <input
            id="xInput"
            type="number"
            placeholder="Tile X"
            style="
              background: #0f172a;
              border: 1px solid #334155;
              border-radius: 8px;
              padding: 8px;
              color: white;
              font-size: 14px;
              width: 100%;
            "
          />
          <input
            id="yInput"
            type="number"
            placeholder="Tile Y"
            style="
              background: #0f172a;
              border: 1px solid #334155;
              border-radius: 8px;
              padding: 8px;
              color: white;
              font-size: 14px;
              width: 100%;
            "
          />
        </div>

        <label
          style="display: flex; align-items: center; gap: 6px; font-size: 14px"
        >
          <input type="checkbox" id="gridToggle" checked />
          Show Grid
        </label>
      </div>

      <!-- Elements -->
      <div
        style="
          background: #1e293b;
          padding: 16px;
          border-radius: 12px;
          display: flex;
          flex-direction: column;
          gap: 12px;
        "
      >
        <h3
          style="
            margin: 0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            opacity: 0.6;
          "
        >
          Elements (Drag onto map)
        </h3>

        <div
          style="
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
          "
        >
          <div
            style="
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 4px;
              cursor: grab;
            "
          >
            <div
              class="palette-item"
              draggable="true"
              data-type="player"
              style="
                width: 40px;
                height: 40px;
                background: #ff4e51;
                border-radius: 8px;
                border: 2px solid rgba(255, 255, 255, 0.3);
              "
            ></div>
            <span style="font-size: 12px; opacity: 0.8">Player</span>
          </div>

          <div
            style="
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 4px;
              cursor: grab;
            "
          >
            <div
              class="palette-item"
              draggable="true"
              data-type="cannon"
              style="
                width: 40px;
                height: 40px;
                background: #ffe800;
                border-radius: 8px;
                border: 2px solid rgba(255, 255, 255, 0.3);
              "
            ></div>
            <span style="font-size: 12px; opacity: 0.8">Cannon</span>
          </div>

          <div
            style="
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 4px;
              cursor: grab;
            "
          >
            <div
              class="palette-item"
              draggable="true"
              data-type="enemy"
              style="
                width: 40px;
                height: 40px;
                background: #13e1f2;
                border-radius: 8px;
                border: 2px solid rgba(255, 255, 255, 0.3);
              "
            ></div>
            <span style="font-size: 12px; opacity: 0.8">Enemy</span>
          </div>

          <div
            style="
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 4px;
              cursor: grab;
            "
          >
            <div
              class="palette-item"
              draggable="true"
              data-type="other"
              style="
                width: 40px;
                height: 40px;
                background: #b94ce6;
                border-radius: 8px;
                border: 2px solid rgba(255, 255, 255, 0.3);
              "
            ></div>
            <span style="font-size: 12px; opacity: 0.8">Other</span>
          </div>
        </div>
      </div>

      <!-- Export -->
      <div style="background: #1e293b; padding: 16px; border-radius: 12px">
        <h3
          style="
            margin: 0 0 10px 0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            opacity: 0.6;
          "
        >
          Export
        </h3>
        <button
          id="downloadBtn"
          style="
            background: #2563eb;
            border: none;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            font-weight: 600;
            width: 100%;
          "
        >
          Download PNG
        </button>
      </div>

      <!-- Footer -->
      <div
        style="
          margin-top: auto;
          padding-top: 16px;
          font-size: 12px;
          opacity: 0.6;
          display: flex;
          align-items: center;
          justify-content: space-between;
        "
      >
        <div>Built with ❤️ by x222</div>

        <a
          href="https://github.com/pvme/tilemap-maker"
          target="_blank"
          style="color: #38bdf8; text-decoration: none"
        >
          GitHub
        </a>
      </div>
    </div>

    <!-- Map -->
    <div id="map">
      <div id="mapInner"></div>
    </div>

    <script>
      const TILE_SIZE = 512;
      const SUB_TILES = 15;
      const MIN_ZOOM = 0.4;
      const MAX_ZOOM = 3;
      const ZOOM_PER_SCROLL = 0.001;
      const BUFFER = 1;
      const FRAME_WIDTH = 20;

      const state = {
        worldX: 177,
        worldY: 684,
        zoom: 0.7,
        showGrid: true,
        elements: [],
        selectedIndex: null,
        dragging: false,

        exportMode: false,
        cropRect: null,
        cropDragging: false,
        cropResizing: false,
        cropHandle: null,
        creatingCrop: false,
      };

      const params = new URLSearchParams(window.location.search);
      if (params.has("x")) state.worldX = parseFloat(params.get("x"));
      if (params.has("y")) state.worldY = parseFloat(params.get("y"));
      if (params.has("z")) state.zoom = parseFloat(params.get("z"));
      if (params.has("e")) {
        try {
          state.elements = JSON.parse(atob(params.get("e")));
        } catch {}
      }

      const map = document.getElementById("map");
      const inner = document.getElementById("mapInner");
      const xInput = document.getElementById("xInput");
      const yInput = document.getElementById("yInput");
      const gridToggle = document.getElementById("gridToggle");
      const downloadBtn = document.getElementById("downloadBtn");

      const tileCache = new Map();

      const gridLayer = document.createElement("canvas");
      map.appendChild(gridLayer);

      const toolbar = document.createElement("div");
      toolbar.className = "element-toolbar";
      map.appendChild(toolbar);

      function runeUrl(x, y) {
        return `https://tilemap-proxy-155908141849.europe-west1.run.app?x=${x}&y=${y}`;
      }

      function updateTransform() {
        inner.style.transform = `translate(${-state.worldX * TILE_SIZE * state.zoom}px,
                     ${-state.worldY * TILE_SIZE * state.zoom}px)
           scale(${state.zoom})`;
        xInput.value = state.worldX.toFixed(6);
        yInput.value = state.worldY.toFixed(6);
        drawGrid();
        positionToolbar();
      }

      function updateURL() {
        const url = new URL(window.location);
        url.searchParams.set("x", state.worldX.toFixed(6));
        url.searchParams.set("y", state.worldY.toFixed(6));
        url.searchParams.set("z", state.zoom.toFixed(6));
        url.searchParams.set("e", btoa(JSON.stringify(state.elements)));
        history.replaceState(null, "", url);
      }

      function visibleBounds() {
        const viewW = map.clientWidth / state.zoom;
        const viewH = map.clientHeight / state.zoom;

        const startX = Math.floor(state.worldX) - BUFFER;
        const startY = Math.floor(state.worldY) - BUFFER;

        const endX = startX + Math.ceil(viewW / TILE_SIZE) + BUFFER * 2;
        const endY = startY + Math.ceil(viewH / TILE_SIZE) + BUFFER * 2;

        return { startX, startY, endX, endY };
      }

      function syncTiles() {
        const bounds = visibleBounds();
        const needed = new Set();

        for (let y = bounds.startY; y <= bounds.endY; y++) {
          for (let x = bounds.startX; x <= bounds.endX; x++) {
            const key = x + ":" + y;
            needed.add(key);
            if (!tileCache.has(key)) {
              const tile = createTile(x, y);
              tileCache.set(key, tile);
              inner.appendChild(tile);
            }
          }
        }

        for (const [key, tile] of tileCache) {
          if (!needed.has(key)) {
            tile.remove();
            tileCache.delete(key);
          }
        }
      }

      function createTile(x, y) {
        const wrapper = document.createElement("div");
        wrapper.className = "tile";
        wrapper.style.left = x * TILE_SIZE + "px";
        wrapper.style.top = y * TILE_SIZE + "px";

        const img = document.createElement("img");
        img.src = runeUrl(x, y);
        img.draggable = false;
        img.onerror = () => (img.style.display = "none");

        wrapper.appendChild(img);
        return wrapper;
      }

      function drawGrid() {
        if (!state.showGrid) {
          gridLayer.style.display = "none";
          return;
        }
        gridLayer.style.display = "block";

        const w = map.clientWidth;
        const h = map.clientHeight;
        const dpr = window.devicePixelRatio || 1;

        gridLayer.width = w * dpr;
        gridLayer.height = h * dpr;
        gridLayer.style.width = w + "px";
        gridLayer.style.height = h + "px";

        const ctx = gridLayer.getContext("2d");
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, w, h);

        const worldStep = TILE_SIZE / SUB_TILES;
        const screenStep = Math.round(worldStep * state.zoom);

        const offsetX = Math.round(
          -((state.worldX * TILE_SIZE) % worldStep) * state.zoom,
        );
        const offsetY = Math.round(
          -((state.worldY * TILE_SIZE) % worldStep) * state.zoom,
        );

        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.lineWidth = 1;

        for (let x = offsetX; x < w; x += screenStep) {
          ctx.beginPath();
          ctx.moveTo(Math.round(x) + 0.5, 0);
          ctx.lineTo(Math.round(x) + 0.5, h);
          ctx.stroke();
        }

        for (let y = offsetY; y < h; y += screenStep) {
          ctx.beginPath();
          ctx.moveTo(0, Math.round(y) + 0.5);
          ctx.lineTo(w, Math.round(y) + 0.5);
          ctx.stroke();
        }
      }

      function clearSelection() {
        if (state.selectedIndex == null) return;
        state.selectedIndex = null;
        renderElements();
        renderToolbar();
      }

      /* ELEMENTS */

      function snap(worldX, worldY) {
        return {
          x: Math.floor(worldX * SUB_TILES),
          y: Math.floor(worldY * SUB_TILES),
        };
      }

      function renderElements() {
        document.querySelectorAll(".map-element").forEach((el) => el.remove());
        const cellSize = TILE_SIZE / SUB_TILES;

        state.elements.forEach((el, i) => {
          const div = document.createElement("div");
          div.className = "map-element";
          if (i === state.selectedIndex) div.classList.add("selected");

          div.style.background =
            el.type === "player"
              ? "#ff4e51"
              : el.type === "cannon"
                ? "#ffe800"
                : el.type === "enemy"
                  ? "#13e1f2"
                  : "#b94ce6";

          div.style.width = Math.round(el.width * cellSize) + "px";
          div.style.height = Math.round(el.height * cellSize) + "px";
          const rawLeft = (el.x * TILE_SIZE) / SUB_TILES;
          const rawTop = (el.y * TILE_SIZE) / SUB_TILES;

          div.style.left = Math.round(rawLeft) + "px";
          div.style.top = Math.round(rawTop) + "px";

          div.textContent = el.label || "";

          div.addEventListener("click", (e) => {
            e.stopPropagation();
            state.selectedIndex = i;
            renderElements();
            renderToolbar();
          });

          inner.appendChild(div);
        });

        positionToolbar();
      }

      /* Toolbar */

      function renderToolbar() {
        if (state.selectedIndex == null) {
          toolbar.style.display = "none";
          return;
        }

        const el = state.elements[state.selectedIndex];

        toolbar.innerHTML = `
          W:<input type="number" min="1" max="10" value="${el.width}">
          H:<input type="number" min="1" max="10" value="${el.height}">
          <input type="text" placeholder="Label" value="${el.label || ""}">
          <button>✕</button>
        `;

        const inputs = toolbar.querySelectorAll("input");

        inputs[0].oninput = (e) => {
          el.width = Math.max(1, parseInt(e.target.value) || 1);
          renderElements();
          updateURL();
        };
        inputs[1].oninput = (e) => {
          el.height = Math.max(1, parseInt(e.target.value) || 1);
          renderElements();
          updateURL();
        };
        inputs[2].oninput = (e) => {
          el.label = e.target.value;
          renderElements();
          updateURL();
        };

        toolbar.querySelector("button").onclick = () => {
          state.elements.splice(state.selectedIndex, 1);
          state.selectedIndex = null;
          renderElements();
          renderToolbar();
          updateURL();
        };

        toolbar.style.display = "flex";
        positionToolbar();
      }

      function positionToolbar() {
        if (state.selectedIndex == null) return;

        const el = state.elements[state.selectedIndex];
        const worldCellX = el.x / SUB_TILES;
        const worldCellY = el.y / SUB_TILES;

        const px = (worldCellX - state.worldX) * TILE_SIZE * state.zoom;
        const py = (worldCellY - state.worldY) * TILE_SIZE * state.zoom;

        toolbar.style.left = px + "px";
        toolbar.style.top = py - 40 + "px";
      }

      /* Sidebar Controls */

      xInput.value = state.worldX;
      yInput.value = state.worldY;

      xInput.onchange = () => {
        state.worldX = parseFloat(xInput.value) || 0;
        updateTransform();
        syncTiles();
        updateURL();
      };

      yInput.onchange = () => {
        state.worldY = parseFloat(yInput.value) || 0;
        updateTransform();
        syncTiles();
        updateURL();
      };

      gridToggle.checked = state.showGrid;
      gridToggle.onchange = () => {
        state.showGrid = gridToggle.checked;
        drawGrid();
      };

      downloadBtn.onclick = () => {
        html2canvas(map, { backgroundColor: null }).then((canvas) => {
          const link = document.createElement("a");
          link.download = "tilemap.png";
          link.href = canvas.toDataURL();
          link.click();
        });
      };

      /* Pan + Zoom */

      map.addEventListener("pointerdown", (e) => {
        if (toolbar.contains(e.target)) return;
        if (state.exportMode) return;
        if (e.target.classList.contains("map-element")) return;
        clearSelection();

        state.dragging = true;
        map.classList.add("dragging");
        state.startX = e.clientX;
        state.startY = e.clientY;
        state.originX = state.worldX;
        state.originY = state.worldY;
      });

      window.addEventListener("pointermove", (e) => {
        if (!state.dragging) return;
        const dx = (e.clientX - state.startX) / (TILE_SIZE * state.zoom);
        const dy = (e.clientY - state.startY) / (TILE_SIZE * state.zoom);
        state.worldX = state.originX - dx;
        state.worldY = state.originY - dy;
        updateTransform();
        syncTiles();
        updateURL();
      });

      window.addEventListener("pointerup", () => {
        state.dragging = false;
        map.classList.remove("dragging");
      });

      map.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          clearSelection();

          const rect = map.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;

          const worldMouseX = state.worldX + mx / (TILE_SIZE * state.zoom);
          const worldMouseY = state.worldY + my / (TILE_SIZE * state.zoom);

          state.zoom -= e.deltaY * ZOOM_PER_SCROLL;

          state.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, state.zoom));

          const safeStep = 15 / 512; // keeps grid pixel-aligned
          state.zoom = Math.round(state.zoom / safeStep) * safeStep;

          state.worldX = worldMouseX - mx / (TILE_SIZE * state.zoom);
          state.worldY = worldMouseY - my / (TILE_SIZE * state.zoom);

          updateTransform();
          syncTiles();
          updateURL();
        },
        { passive: false },
      );

      document.querySelectorAll(".palette-item").forEach((item) => {
        item.addEventListener("dragstart", (e) => {
          e.dataTransfer.setData("type", item.dataset.type);
        });
      });

      map.addEventListener("dragover", (e) => e.preventDefault());

      map.addEventListener("drop", (e) => {
        e.preventDefault();
        clearSelection();
        const type = e.dataTransfer.getData("type");
        const rect = map.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        const worldX = state.worldX + mx / (TILE_SIZE * state.zoom);
        const worldY = state.worldY + my / (TILE_SIZE * state.zoom);

        const snapped = snap(worldX, worldY);

        state.elements.push({
          type,
          x: snapped.x,
          y: snapped.y,
          width: 1,
          height: 1,
          label: "",
        });

        renderElements();
        updateURL();
      });

      /* Download mask overlay  */

      const exportOverlay = document.createElement("div");
      exportOverlay.style.position = "absolute";
      exportOverlay.style.inset = "0";
      exportOverlay.style.pointerEvents = "none";
      exportOverlay.style.zIndex = "1000";
      exportOverlay.style.background = "rgba(0,0,0,0.5)";

      const exportRect = document.createElement("div");
      exportRect.style.position = "absolute";
      exportRect.style.border = "2px dashed white";
      exportRect.style.background = "rgba(255,255,255,0.1)";
      exportRect.style.pointerEvents = "auto";
      exportRect.style.display = "none";

      const handleBR = document.createElement("div");
      handleBR.style.position = "absolute";
      handleBR.style.width = "12px";
      handleBR.style.height = "12px";
      handleBR.style.right = "-6px";
      handleBR.style.bottom = "-6px";
      handleBR.style.background = "white";
      handleBR.style.cursor = "nwse-resize";

      const handleTL = document.createElement("div");
      handleTL.style.position = "absolute";
      handleTL.style.width = "12px";
      handleTL.style.height = "12px";
      handleTL.style.left = "-6px";
      handleTL.style.top = "-6px";
      handleTL.style.background = "white";
      handleTL.style.cursor = "nwse-resize";

      exportRect.appendChild(handleBR);
      exportRect.appendChild(handleTL);
      exportOverlay.appendChild(exportRect);

      function enterExportMode() {
        state.exportMode = true;
        state.cropRect = null;
        downloadBtn.textContent = "Confirm Export";
        map.appendChild(exportOverlay);
        map.style.cursor = "grab";

        const mapRect = map.getBoundingClientRect();

        const size = Math.min(mapRect.width, mapRect.height) * 0.75;

        const x = (mapRect.width - size) / 2;
        const y = (mapRect.height - size) / 2;

        state.cropRect = { x, y, w: size, h: size };

        exportRect.style.display = "block";
        drawCropRect();
      }

      function exitExportMode() {
        state.exportMode = false;
        state.cropRect = null;
        state.cropDragging = false;
        state.cropResizing = false;
        state.creatingCrop = false;
        exportRect.style.display = "none";
        exportOverlay.remove();
        downloadBtn.textContent = "Download PNG";
        map.style.cursor = "grab";
      }

      function drawCropRect() {
        if (!state.cropRect) return;
        const { x, y, w, h } = state.cropRect;

        exportRect.style.display = "block";
        exportRect.style.left = Math.min(x, x + w) + "px";
        exportRect.style.top = Math.min(y, y + h) + "px";
        exportRect.style.width = Math.abs(w) + "px";
        exportRect.style.height = Math.abs(h) + "px";
      }

      map.addEventListener("pointerdown", (e) => {
        if (!state.exportMode) return;

        const rect = map.getBoundingClientRect();

        if (e.target === handleBR) {
          state.cropResizing = true;
          state.cropHandle = "br";
          return;
        }

        if (e.target === handleTL) {
          state.cropResizing = true;
          state.cropHandle = "tl";
          return;
        }

        if (e.target === exportRect) {
          state.cropDragging = true;
          state.dragStartX = e.clientX;
          state.dragStartY = e.clientY;
          state.startRect = { ...state.cropRect };
          return;
        }

        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
      });

      window.addEventListener("pointermove", (e) => {
        if (!state.exportMode) return;

        const rect = map.getBoundingClientRect();

        if (state.creatingCrop && state.cropRect) {
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          state.cropRect.w = x - state.cropRect.x;
          state.cropRect.h = y - state.cropRect.y;
          drawCropRect();
        }

        if (state.cropDragging) {
          const dx = e.clientX - state.dragStartX;
          const dy = e.clientY - state.dragStartY;
          state.cropRect.x = state.startRect.x + dx;
          state.cropRect.y = state.startRect.y + dy;
          drawCropRect();
        }

        if (state.cropResizing) {
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          if (state.cropHandle === "br") {
            state.cropRect.w = x - state.cropRect.x;
            state.cropRect.h = y - state.cropRect.y;
          } else {
            const right = state.cropRect.x + state.cropRect.w;
            const bottom = state.cropRect.y + state.cropRect.h;
            state.cropRect.x = x;
            state.cropRect.y = y;
            state.cropRect.w = right - x;
            state.cropRect.h = bottom - y;
          }

          drawCropRect();
        }
      });

      window.addEventListener("pointerup", () => {
        state.creatingCrop = false;
        state.cropDragging = false;
        state.cropResizing = false;
      });

      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && state.exportMode) {
          exitExportMode();
        }
      });

      downloadBtn.onclick = async () => {
        if (!state.exportMode) {
          enterExportMode();
          return;
        }

        if (!state.cropRect) {
          exitExportMode();
          return;
        }

        const dpr = window.devicePixelRatio || 1;
        exportOverlay.style.display = "none";

        let fullCanvas;
        try {
          fullCanvas = await html2canvas(map, {
            scale: dpr,
            backgroundColor: null,
            useCORS: true,
          });
        } finally {
          exportOverlay.style.display = "block";
        }

        const crop = {
          x: Math.min(state.cropRect.x, state.cropRect.x + state.cropRect.w),
          y: Math.min(state.cropRect.y, state.cropRect.y + state.cropRect.h),
          w: Math.abs(state.cropRect.w),
          h: Math.abs(state.cropRect.h),
        };

        const legendTypes = [
          ...new Set(state.elements.map((e) => e.type)),
        ].filter((type) =>
          ["player", "cannon", "enemy", "other"].includes(type),
        );

        const LABELS = {
          player: "Player position",
          cannon: "Cannon location",
          enemy: "Enemy position",
          other: "Other",
        };

        const COLORS = {
          player: "#ff4e51",
          cannon: "#ffe800",
          enemy: "#13e1f2",
          other: "#b94ce6",
        };

        const maxColumns = Math.min(4, legendTypes.length);

        const availableWidth = crop.w;
        const itemWidth = 280;
        const gap = 40;
        const squareSize = 28;
        const fontSize = 28;
        const rowHeight = 50;

        let columns = Math.floor((availableWidth + gap) / (itemWidth + gap));
        columns = Math.max(1, Math.min(columns, maxColumns));

        const rows = Math.ceil(legendTypes.length / columns);

        const legendHeight = legendTypes.length ? rows * rowHeight + 40 : 0;

        const totalWidth = crop.w + FRAME_WIDTH * 2;
        const totalHeight = crop.h + legendHeight + FRAME_WIDTH * 3;

        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = totalWidth * dpr;
        exportCanvas.height = totalHeight * dpr;

        const ctx = exportCanvas.getContext("2d");
        ctx.scale(dpr, dpr);

        const grad = ctx.createLinearGradient(
          0,
          0,
          exportCanvas.width,
          exportCanvas.height,
        );
        grad.addColorStop(0, "#111827");
        grad.addColorStop(1, "#1e293b");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, totalWidth, totalHeight);

        ctx.drawImage(
          fullCanvas,
          crop.x * dpr,
          crop.y * dpr,
          crop.w * dpr,
          crop.h * dpr,
          FRAME_WIDTH,
          FRAME_WIDTH,
          crop.w,
          crop.h,
        );

        if (legendTypes.length > 0) {
          ctx.fillStyle = "#0b1a22";
          ctx.fillRect(
            FRAME_WIDTH,
            crop.h + FRAME_WIDTH * 2,
            crop.w,
            legendHeight,
          );

          ctx.font = `bold ${fontSize}px Inter, ui-sans-serif, system-ui`;
          ctx.textBaseline = "middle";
          ctx.fillStyle = "#e5e7eb";

          const startX =
            FRAME_WIDTH +
            (crop.w - (columns * itemWidth + (columns - 1) * gap)) / 2;

          const legendTop = crop.h + FRAME_WIDTH * 2;
          const legendContentHeight = rows * rowHeight;

          const startY =
            legendTop +
            (legendHeight - legendContentHeight) / 2 +
            rowHeight / 2;

          legendTypes.forEach((type, index) => {
            const col = index % columns;
            const row = Math.floor(index / columns);

            const x = startX + col * (itemWidth + gap);
            const y = startY + row * rowHeight;

            ctx.fillStyle = COLORS[type];
            ctx.fillRect(x, y - squareSize / 2, squareSize, squareSize);

            ctx.fillStyle = "#e5e7eb";
            ctx.fillText(LABELS[type], x + squareSize + 20, y);
          });
        }

        const link = document.createElement("a");
        link.download = "tilemap.png";
        link.href = exportCanvas.toDataURL();
        link.click();

        exitExportMode();
      };

      /* Init */
      updateTransform();
      syncTiles();
      drawGrid();
      renderElements();
      renderToolbar();
      updateURL();
    </script>
  </body>
</html>
